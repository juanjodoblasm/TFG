---
title: "Análisis exploratorio"
author: Juanjo Doblas
format: 
  html:
    toc: true
    toc-depth: 3
editor: visual
execute:
  echo: false
  message: false
embed-resources: true
editor_options: 
  chunk_output_type: inline
---

## 1 - Introducción

En este documento realizaremos un análisis exploratorio de los datos que se encuentran en el archivo `causas_muerte.xls`.

Esta tabla de datos contiene información sobre las causas de muerte en la mayoría de países del mundo desde el año 1990 hasta el 2019, así como algunas covariables.

Primero de todo cargaremos las librerías necesarias para realizar el análisis.

```{r librerias, include=FALSE}
# 1
library(readxl)
library(tidyverse)

# 2
library(ggplot2)
library(xtable)

# 3
library(compositions)
library(zCompositions)

# 4
library(ggcorrplot)

# 6
library(factoextra)
library(gridExtra)

# 7
library(ggpubr)

# 8
library(NBZIMM)
library(pscl)
```

Ahora, carguemos nuestra base de datos y presentemos un resumen.

```{r dataset, warning=FALSE}
data <- read_excel("causas_muerte.xls") %>% 
  # Transformamos la variable año en ordinal
  mutate(año = as.ordered((año))) %>% 
  mutate(idh = idh*100) %>% 
  # Creamos una variable con el total de muertes
  rowwise() %>%  mutate(total_muertes = sum(c_across(meningitis:hepatitis_aguda)), .after = hepatitis_aguda) %>% ungroup()

data %>% glimpse
```

### 1.1 - Descripción de las variables

Realicemos una pequeña descripción de cada variable:

-   *pais*: país del que proceden los datos. Veamos los países que se recogen.

```{r paises}
data[, "pais"] %>% unique
```

-   *codigo_Pais*: código de 3 letras para los nombres de los países según la norma ISO 3166-1 alfa-3.

-   *año*: año en el que se recogen los datos. Veamos que no falta ningún año en ningún país desde 1990 hasta 2019. Lo veremos en la siguiente tabla que recoge el número de muestras, y por tanto de países, por cada año.

```{r paises años}
data[, "año"] %>% table
```

-   *poblacion*: número de habitantes de cada país en cada año.

Las variables desde la columna *meningitis* hasta *hepatitis_aguda* recogen el número de muertes por la causa que da nombre a la variable en cada país y cada año.

-   *total_muertes*: Es el número de muertes totales que ha habido en cada año en cada país. Es la suma de todas las causas de muerte.

-   *pib*: producto interior bruto en millones de dólares. Expresa el valor monetario de la producción de bienes y servicios de demanda final.

-   *idh*: índice de desarrollo humano. Se calcula en base a la esperanza de vida, el nivel de educación y el ingreso per cápita.

-   *esperanza_vida_m*: esperanza de vida de las mujeres en años.

-   *esperanza_vida_h*: esperanza de vida de los hombres en años.

-   *esperanza_vida*: esperanza de vida de la población en años.

-   *emisiones_CO2*: cantidad de CO2 emitido en millones de toneladas.

-   *emisiones_CO2_PIB*: cantidad de CO2 emitido por cada 1000 dólares de PIB en kilogramos.

-   *emisiones_CO2_per_capita*: cantidad de CO2 emitido per cápita en toneladas.

## 2 - Transformación de datos

En este apartado realizaremos una transformación a la base de datos con el objetivo de simplificar el posterior análisis. Estas transformaciones incluyen la reducción de países, la agrupación de causas de muerte y la eliminación de algunas covariables

### 2.1 - Reducción de países

Primero de todo, nos restringiremos a los datos que nos proporcionan los países europeos para así reducir el número de individuos. Filtremos los países de este continente en nuestra base de datos.

```{r datos europa}
# Lista de países de Europa
paises_eu <- c("Albania", "Andorra", "Armenia", "Austria", "Azerbaiyán",
               "Bélgica", "Bielorrusia", "Bosnia-Herzegovina", "Bulgaria", "Chipre",
               "Croacia", "Dinamarca", "Eslovaquia", "Eslovenia", "España",
               "Estonia", "Finlandia", "Francia", "Georgia (desambiguación)", "Grecia",
               "Hungría", "Irlanda (isla)", "Islandia", "Italia", "Kazajistán",
               "Letonia", "Lituania", "Luxemburgo", "Malta", "Moldavia",
               "Mónaco", "Montenegro", "Noruega", "Países Bajos", "Polonia",
               "Portugal", "Reino Unido", "Republica Checa", "República de Macedonia", "Rumania",
               "Rusia", "Serbia", "Suecia", "Suiza", "Turquía",
               "Ucrania")

# Filtramos los datos
data_eu <- data %>% filter(pais %in% paises_eu)
```

### 2.2 - Agrupación de causas de muerte

Veamos la distribución temporal de la cantidad de defunciones de cada causa mediante gráficos de cajas, ordenados de mayor a menor cantidad de muertes.

```{r distribucion muertes}
total_muertes_año <- data_eu %>%
  dplyr::select(año, meningitis:hepatitis_aguda) %>%
  group_by(año) %>%
  summarise(across(everything(), ~ sum(.)))

total_muertes_año %>% 
  pivot_longer(cols = -año, names_to = "causa_muerte", values_to = "muerte") %>%
  mutate(cm = factor(causa_muerte), muerte = muerte + 1) %>% 
  ggplot(aes(x = fct_reorder(cm, -muerte), y = muerte)) +
  scale_y_log10() +
  geom_boxplot(width = 0.75, color = "black") +
  theme_minimal() +
  labs(x = "Causa de muerte", y = "Número de muertes") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

A continuación, una tabla con el número de defunciones totales por cada causa, también ordenada de mayor a menor cantidad de muertes.

```{r tabla muertes, fig.width=8}
tabla_total_muertes <- total_muertes_año %>%
  summarise(across(meningitis:hepatitis_aguda, sum)) %>%
  pivot_longer(cols = everything(), names_to = "Causa", values_to = "Total_muertes") %>%
  arrange(desc(Total_muertes)) %>%
  tableGrob()

grid.arrange(tabla_total_muertes[1:16], tabla_total_muertes[c(1, 17:32)], ncol = 2)
```

Como podemos ver, hay algunas causas de muerte que apenas causan impacto. Por ello, con el objetivo de reducir dimensionalidad, vamos a agruparlas siguiendo el criterio de la OMS en [este enlace](https://icd.who.int/browse/2024-01/mms/en). Los grupos que nos quedan son los siguientes:

-   Enfermedades infecciosas o parasitarias (*enf_infec_paras*). En este grupo incluimos *meningitis*, *malaria*, *VIH* y *tuberculosis*.

-   Enfermedades del sistema nervioso (*enf_sist_nervioso*). En este grupo incluimos *alzheimer* y *parkinson*.

-   Enfermedades endocrinas, nutricionales o metabólicas (*enf_metabolicas*). En este grupo incluimos *def_nutricionales*, *diabetes_mellitus* y *desnutrición_energetica*.

-   Causas externas de morbilidad o mortalidad, lesiones y envenenamientos (*causas_externas*). En este grupo incluimos *ahogo*, *violencia_inter*, *autolesiones*, *exp_fuer_naturaleza*, *conflicto_terrorismo*, *lesiones_carretera*, *exp_amb_temperatura*, *envenenamientos* y *fuego_calientes*.

-   Causas relacionadas con el embarazo, parto o puerperio (en la madre) y afecciones en el periodo perinatal (en el hijo) (*trastornos_embarazo*). En este grupo incluimos *trastornos_maternos* y *trastornos_neonatales*.

-   Trastornos mentales, del comportamiento o del desarrollo neurológico (*trastornos_mentales*). En este grupo incluimos *trastornos_cons_drogas* y *trastornos_Cons_alcohol*.

-   Enfermedades del sistema circulatorio (*enf_cardiovasculares*). En este grupo incluimos *enf_cardiovasculares*.

-   Enfermedades del sistema respiratorio (*infecciones_respi*). En este grupo incluimos *infecciones_respi*.

-   Enfermedades del sistema digestivo (*enf_sist_digestivo*). En este grupo incluimos *enf_diarreicas*, *cirrosis_crónicas*, *enfermedades_digestivas* y *hepatitis_aguda*.

-   Neoplasias (*neoplasias*). En este grupo incluimos *neoplasias*.

-   Enfermedades crónicas (*enf_cronicas*). En este grupo incluimos *enfermedad_crónica* y *enfermedades_cronicas*.

Creemos la nueva base de datos con las causas de muerte agrupadas.

```{r datos causas agrupadas}
data_eu_agrupado <- data_eu %>%
  mutate(
    enf_infec_paras = rowSums(dplyr::select(., meningitis, malaria, VIH, tuberculosis)),
    enf_sist_nervioso = rowSums(dplyr::select(., alzheimer, parkinson)),
    enf_metabolicas = rowSums(dplyr::select(., def_nutricionales, diabetes_mellitus, 
                                     desnutrición_energetica)),
    causas_externas = rowSums(dplyr::select(., ahogo, violencia_inter, autolesiones, exp_fuer_naturaleza,
                                     conflicto_terrorismo, lesiones_carretera, exp_amb_temperatura,
                                     envenenamientos, fuego_calientes)),
    trastornos_embarazo = rowSums(dplyr::select(., trastornos_maternos, trastornos_neonatales)),
    trastornos_mentales = rowSums(dplyr::select(., trastornos_cons_drogas, trastornos_Cons_alcohol)),
    enf_sist_digestivo = rowSums(dplyr::select(., enf_diarreicas, cirrosis_crónicas,
                                        enfermedades_digestivas, hepatitis_aguda)),
    enf_cronicas = rowSums(dplyr::select(., enfermedad_crónica, enfermedades_cronicas)),
    .after = poblacion
  ) %>%
  dplyr::select(-meningitis, -malaria, -VIH, -tuberculosis,
         -alzheimer, -parkinson,
         -def_nutricionales, -diabetes_mellitus, -desnutrición_energetica,
         -ahogo, -violencia_inter, -autolesiones, -exp_fuer_naturaleza, -conflicto_terrorismo,
         -lesiones_carretera, -exp_amb_temperatura, -envenenamientos, -fuego_calientes,
         -trastornos_maternos, -trastornos_neonatales,
         -trastornos_cons_drogas, -trastornos_Cons_alcohol,
         -enf_diarreicas, -cirrosis_crónicas, -enfermedades_digestivas, -hepatitis_aguda,
         -enfermedad_crónica, -enfermedades_cronicas) %>% 
  relocate(enf_cardiovasculares:infecciones_respi, .after = trastornos_mentales) %>%
  relocate(neoplasias, .after = enf_sist_digestivo)
```

Veamos de nuevo la distribución temporal de la cantidad de defunciones de cada causa, ahora con la nueva agrupación.

```{r distribucion muertes agrupadas}
total_muertes_agrupadas_año <- data_eu_agrupado %>%
  dplyr::select(año, enf_infec_paras:enf_cronicas) %>%
  group_by(año) %>%
  summarise(across(everything(), ~ sum(.)))

total_muertes_agrupadas_año %>% 
  pivot_longer(cols = -año, names_to = "causa_muerte", values_to = "muerte") %>%
  mutate(cm = factor(causa_muerte)) %>% 
  ggplot(aes(x = fct_reorder(cm, -muerte), y = muerte)) +
  geom_boxplot(width = 0.5, color = "black") +
  scale_y_log10() +
  theme_minimal() +
  labs(x = "Causa de muerte", y = "Número de muertes") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

A continuación, de nuevo, una tabla con el número de defunciones totales por cada causa.

```{r tabla muertes agrupadas}
tabla_total_muertes_agrupadas <- total_muertes_agrupadas_año %>%
  summarise(across(enf_infec_paras:enf_cronicas, sum)) %>%
  pivot_longer(cols = everything(), names_to = "Causa", values_to = "Total_muertes") %>%
  arrange(desc(Total_muertes)) %>%
  tableGrob()

grid.arrange(tabla_total_muertes_agrupadas, ncol = 1)
```

### 2.3 - Eliminación de algunas covariables

Recordemos que las covariables que tenemos son *población*, *pib*, *idh*, *esperanza_vida_m*, *esperanza_vida_h*, *esperanza_vida*, *emisiones_CO2*, *emisiones_CO2_PIB* y *emisiones_CO2_per_capita*. Sin embargo, notemos que nos proporcionan información redundante. El Índice de Desarrollo Humano se calcula a partir del PIB y de la esperanza de vida, así que nos podríamos deshacer de estas variables. Por otro lado, cuanta más población tenga un país, más emisiones de CO2 habrá, por lo que también podemos eliminar la variable *emisiones_CO2*. En efecto, podemos ver las altas correlaciones que tienen las variables entre sí en la siguiente matriz de correlaciones.

```{r matriz correlaciones covariables}
data_eu_agrupado %>%
  dplyr::select(poblacion, pib:emisiones_CO2_per_capita) %>%
  cor() %>%
  ggcorrplot(type = "upper", lab = TRUE, colors = c("red", "white", "blue"),
             title = "Matriz de correlaciones de las covariables")
```

Podemos ver efectivamente que *idh* está altamente correlacionado con las variables relacionadas con la esperanza de vida. También vemos una alta correlación entre *poblacion* y *emisiones_CO2*. Sin embargo, la correlación entre *idh* y *pib* no es tan alta, pero esto es debido a que el IDH se calcula a partir del logaritmo del PIB, por lo que no tienen alta correlación lineal.

De esta forma, dejaremos únicamente las covariables *poblacion*, *idh*, *emisiones_CO2_PIB* y *emisiones_CO2_per_capita* en la base de datos.

```{r eliminacion covariables}
new_data <- data_eu_agrupado %>%
  dplyr::select(-starts_with("esperanza"), -emisiones_CO2,-pib)

new_data %>% head(5) %>% glimpse %>% xtable()
```

## 3 - Tratamiento de datos composicionales

Las variables que nos dan información sobre las causas de muerte tienen naturaleza composicional. En efecto, todas las entradas son positivas, ya que son conteos de muertes; y la única información relevante en cada fila es la contenida en su vector de proporciones, ya que este nos da el porcentaje de muertes por cada causa.

Antes de poder aplicar técnicas de análisis de datos composicionales hay que tratar los datos siguiendo los pasos siguientes:

1.  Se sustituyen (*imputan*) los ceros.

2.  Se transforman logarítmicamente los datos.

### 3.1 - Imputación de ceros

Hay varias estrategias para imputar ceros. Primero, nos interesa saber cuantos conteos de ceros hay en cada variable. Lo vemos en la siguiente tabla:

```{r conteo ceros}
causas_muerte <- new_data %>%
  dplyr::select(enf_infec_paras:enf_cronicas)

tabla_ceros <- summarise(causas_muerte, across(everything(), ~ sum(. == 0)))

tabla_ceros %>% glimpse
```

La siguiente salida nos da el porcentaje de ceros:

```{r porcentaje ceros}
100*sum(tabla_ceros) / (nrow(causas_muerte)*ncol(causas_muerte))
```

Como el porcentaje de ceros es menor a $10\%$, los sustituiremos por $0,65$.

### 3.2 - Transformación CLR

Utilizaremos la transformación logarítmica centrada, que consiste en dividir cada entrada por la media geométrica de la fila y aplicarle un logaritmo.

```{r transformacion clr}
new_data_clr <- new_data

#new_data_clr[, 5:15] <- cmultRepl(new_data_clr[, 5:15], method="GBM", output="p-counts", suppress.print=TRUE, z.warning=0.99)

new_data_clr[, 5:15] <- causas_muerte %>% 
  # Imputación de ceros
  mutate(across(where(is.numeric), ~ replace(., . == 0, 0.65))) %>% 
  clr %>%
  as_tibble()

new_data_clr %>% glimpse
```

## 4 - Matriz de correlaciones

Analicemos la matriz de correlaciones de las causas de muerte y las covariables. Usaremos la correlación de Spearman y no la de Pearson ya que nuestras variables de interés, las causas de muerte, son discretas.

```{r matriz correlaciones, fig.width=9}
new_data_clr %>%
  dplyr::select(where(is.numeric)) %>%
  cor(., method = "spearman") %>% 
  ggcorrplot(type = "upper", lab = TRUE, lab_size = 2.25, colors = c("red", "white", "blue"),
             title = "Matriz de correlaciones")
```

Fijémonos primero en las correlaciones entre causas de muerte y covariables. Las variables *población* y *emisiones_CO2_per_capita* apenas tiene correlación con las causas de muerte. La variable *emisiones_CO2_PIB* tiene correlaciones más altas, las más significativas son con *enf_sist_nervioso* y *causas_externas*. Por otro lado, la variable *idh* presenta altas correlaciones con algunas causas, tanto positivamente como negativamente. Esto es debido a que un IDH bajo corresponde a países poco desarrollados y podemos ver en las correlaciones negativas enfermedades que suelen ser comunes en estos países: enfermedades infecciosas y parasitarias, las cuales recordemos que engloban a meningitis, malaria, VIH y tuberculosis; y trastornos del embarazo, los cuales engloban trastornos maternos y neonatales. Luego, en las correlaciones positivas, podemos ver enfermedades del sistema nervioso, que engloba alzheimer y parkinson; neoplasias y enfermedades crónicas.

Por último, vemos que hay algunas enfermedades bastante correlacionadas y otras que no. La correlación positiva que más destaca es entre enfermedades del sistema nervioso y neoplasias, con un valor de $0.82$; mientras que la correlación negativa más destacada es entre enfermedades del sistema nervioso y trastornos del embarazo, con un valos de $-0.72$. La correlaciones más pequeña en valor absoluto, con un valor de $0$, corresponde a enfermedades metabólicas con infecciones respiratorias.

Cabe destacar el caso de la variable *total_muertes* que no tiene ninguna correlación considerable exceptuando con *población*, la cual es obvia.

## 5 - Tendencias temporales

En este apartado vamos a estudiar las tendencias temporales de cada causa

Vamos a trabajar con un tibble donde hay $30$ filas, una para cada año, donde los conteos de cada enfermedad son la suma de los conteos en todos los países de Europa en ese año.

```{r muertes totales por año}
total_muertes_agrupadas_año %>% 
  glimpse
```

Ahora lo transformamos en una serie temporal y elaboramos los gráficos.

```{r serie temporal}
total_muertes_agrupadas_año.ts <- ts(total_muertes_agrupadas_año[-1], start = c(1990), end = c(2019), frequency = 1)
```

```{r graficos 1, fig.width=10, fig.height=4}
# Sin notación científica
options(scipen = 5)

par(mfrow = c(1, 2), las = 1)

plot.ts(total_muertes_agrupadas_año.ts[, "enf_infec_paras"], ylab = "",
        xlab = "Año", main = "Enfermedades infecciosas y parasitarias")
plot.ts(total_muertes_agrupadas_año.ts[, "causas_externas"], ylab = "",
        xlab = "Año", main = "Causas externas")
```

En estos primeros dos gráficos vemos un comportamiento alcista durante los primeros años hasta alcanzar sus máximos alrededor de 1995, para luego seguir con un comportamiento bajista y acabar en 2019 con una cantidad inferior a la cantidad de muertes iniciales, aunque en el segundo gráfico es bastante más inferior que en el primero.

```{r graficos 2, fig.width=10, fig.height=9}
par(mfrow = c(3, 2), las = 1)

plot.ts(total_muertes_agrupadas_año.ts[, "enf_sist_nervioso"], ylab = "",
        xlab = "Año", main = "Enfermedades del sistema nervioso")
plot.ts(total_muertes_agrupadas_año.ts[, "enf_metabolicas"], ylab = "",
        xlab = "Año", main = "Enfermedades metabólicas")
plot.ts(total_muertes_agrupadas_año.ts[, "enf_sist_digestivo"], ylab = "",
        xlab = "Año", main = "Enfermedades del sistema digestivo")
plot.ts(total_muertes_agrupadas_año.ts[, "neoplasias"], ylab = "",
        xlab = "Año", main = "Neoplasias")
plot.ts(total_muertes_agrupadas_año.ts[, "enf_cronicas"], ylab = "",
        xlab = "Año", main = "Enfermedades crónicas")
```

En estos cuatro gráficos podemos ver una clara tendencia alcista del número de muertes. Sin embargo, las defunciones por enfermedades del sistema digestivo se han estabilizado entre $550000$ y $600000$ a partir de 2005, y en las defunciones por enfermedades crónicas tenemos la tendencia alcista a partir de 2006.

```{r graficos 3, fig.width=5, fig.height=4}
par(mfrow = c(1, 1), las = 1)

plot.ts(total_muertes_agrupadas_año.ts[, "trastornos_embarazo"], ylab = "",
        xlab = "Año", main = "Trastornos del embarazo")
```

En este gráfico podemos apreciar una clara tendencia bajista, siendo la cantidad de muertes de 2019 más de un $75\%$ inferior a la cantidad de 1990.

```{r graficos 4, fig.width=10, fig.height=6}
par(mfrow = c(2, 2), las = 1)

plot.ts(total_muertes_agrupadas_año.ts[, "trastornos_mentales"], ylab = "",
        xlab = "Año", main = "Trastornos mentales")
plot.ts(total_muertes_agrupadas_año.ts[, "enf_cardiovasculares"], ylab = "",
        xlab = "Año", main = "Enfermedades cardiovasculares")
plot.ts(total_muertes_agrupadas_año.ts[, "infecciones_respi"], ylab = "",
        xlab = "Año", main = "Infecciones respiratorias")
```

En estos últimos tres gráficos se observa un comportamiento sinusoidal, con tendencias alcistas y bajistas en diferentes ventanas temporales. Las primeras dos causas tienen su mínimo en 1990, mientras que la tercera lo tiene en 2011. Por otro lado, el máximo de la primera lo alcanza en 2005, la segunda en 2003 y la tercera en 1995.

Por último, comparemos la evolución de todas las causas en tres gráficos diferentes: número de muertes bajo, número de muertes medio y número de muertes alto.

```{r grafico resumen, fig.height=8, fig.width=8}
par(mfrow = c(3, 2), las = 1)

colores = c("blue", "red", "green", "purple", "orange", "black", "pink", "yellow", "cyan",
            "darkgreen", "magenta")
nombres_causas = c("Enfermedades infecciosas y parasitarias", "Enfermedades metabólicas",
                   "Trastornos del embarazo", "Trastornos mentales",
                   "Enfermedades del sistema nervioso", "Causas externas",
                   "Infecciones respiratorias", "Enfermedades del sistema digestivo",
                   "Enfermedades crónicas", "Enfermedades cardiovasculares", "neoplasias")

ts.plot(total_muertes_agrupadas_año.ts[, c("enf_infec_paras", "enf_metabolicas",
                                           "trastornos_embarazo", "trastornos_mentales")],
        main = "Número de muertes bajo", col = colores[1:4], lwd = 2)

plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")  # Gráfico vacío para la leyenda
legend("left", legend = nombres_causas[1:4], col = colores[1:4], lwd = 2, bty = "n")

ts.plot(total_muertes_agrupadas_año.ts[, c("enf_sist_nervioso", "causas_externas",
                                           "infecciones_respi", "enf_sist_digestivo",
                                           "enf_cronicas")],
        main = "Número de muertes medio", col = colores[5:9], lwd = 2)

plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")  # Gráfico vacío para la leyenda
legend("left", legend = nombres_causas[5:9], col = colores[5:9], lwd = 2, bty = "n")

ts.plot(total_muertes_agrupadas_año.ts[, c("enf_cardiovasculares", "neoplasias")],
        main = "Número de muertes alto", col = colores[10:11], lwd = 2)

plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")  # Gráfico vacío para la leyenda
legend("left", legend = nombres_causas[10:11], col = colores[10:11], lwd = 2, bty = "n")

# Notación científica predeterminada
#options(scipen = 0)
```

## 6 - Análisis en componentes principales

En este apartado realizaremos análisis en componentes principales (ACP). Veremos tres análisis: con las medianas temporales para cada país, en 1990 y en 2019; con el objetivo de ver si se producen cambios significativos a lo largo del tiempo en las agrupaciones de países.

### ACP medianas temporales

En este primer análisis se hará sobre un conjunto de datos donde para cada país tendremos la mediana de cada causa de muerte y del IDH con respecto al tiempo. Construyamos primero este conjunto de datos.

```{r mediana temporal muertes}
new_data_medianas <- new_data %>%
  group_by(codigo_Pais) %>%
  summarise(across(c(enf_infec_paras:enf_cronicas, idh), median)) %>%
  ungroup()
```

Veamos si hay alguna entrada que sea $0$.

```{r conteo ceros medianas}
new_data_medianas %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  summarise(total_ceros = sum(across(where(is.numeric), ~ sum(. == 0)))) %>% 
  glimpse
```

Como hay dos $0$, para poder realizar la transformación *clr* lo tendremos que imputar. Lo vamos a sustituir por $0.65$ `r #Si no se imputan 0, clr deja ese espacio como 0` y luego aplicaremos la transformación *clr* y centraremos los datos.

```{r mediana temporal muertes clr}
new_data_medianas_clr <- new_data_medianas %>%
  mutate(across(enf_infec_paras:enf_cronicas, ~ replace(., . == 0, 0.65)))

new_data_medianas_clr[, 2:12] <- new_data_medianas_clr %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  clr %>%
  as_tibble

n = nrow(new_data_medianas_clr)

# Matriz de centrado
Hn = diag(n) - 1/n

# Datos centrados
data_cen_medianas <- Hn %*% as.matrix(new_data_medianas_clr[, 2:12]) %>% 
  as_tibble %>%
  mutate(codigo_Pais = new_data_medianas_clr$codigo_Pais, .before = enf_infec_paras,) %>%
  mutate(idh = new_data_medianas_clr$idh)
```

Antes de realizar el método de componentes principales, observemos la matriz de varianzas-covarianzas y la matriz de correlación.

```{r matriz covarianzas medianas}
S_medianas = cov(data_cen_medianas[, 2:12])
cat("Matriz de varianzas-covarianzas\n")
S_medianas
```

Podemos ver que los valores de las varianzas se agrupan entre $0.07881073$ y $0.72369244$, siendo el valor mínimo de *enf_sist_digestivo* y el máximo de *trastornos_mentales*. Debido a esta diferencia entre las varianzas, realizaremos el ACP escalado, ya que si no, las componentes principales le darían más peso a las variables con una alta varianza. Veamos de una forma más clara las varianzas ordenadas de menor a mayor.

```{r varianzas ordenadas medianas}
sort(diag(S_medianas))
```

Por otro lado, la matriz de correlaciones es:

```{r matriz correlacion medianas, fig.height=6}
data_cen_medianas %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  cor(., method = "spearman") %>% 
  ggcorrplot(type = "upper", lab = TRUE, colors = c("red", "white", "blue"),
             title = "Matriz de correlaciones")
```

La mayor correlación positiva se encuentra entre *enf_sist_nervioso* y *neoplasias*, con un valor de $0.76$. Por otro lado, la mayor correlación negativa se encuentra entre *causas_externas* y *enf_cronicas*, con un valor de $-0.66$.

Pasemos al estudio de las componentes principales. Calculemos los valores y vectores propios de la matriz de varianzas-covarianzas.

```{r ACP medianas}
data_ACP_medianas = prcomp(data_cen_medianas[, 2:12], scale = TRUE)

rownames(data_ACP_medianas$x) <- data_cen_medianas$codigo_Pais
```

```{r veps medianas}
veps_medianas = data_ACP_medianas$rotation

cat("Vectores propios\n")
veps_medianas
```

Podemos ver que entre la primera y segunda componente le dan un peso considerable a todas las variables, aunque *enf_sist_digestivo* y *enf_cardiovasculares* son las que menos peso tienen.

```{r vaps medianas}
vaps_medianas = get_eigenvalue(data_ACP_medianas)

cat("Valores propios\n")
vaps_medianas
```

A partir de esta tabla de valores podemos ver que con dos componentes principales nos permiten explicar aproximadamente el $61\%$ de la variación total. Para ver de una manera más detallada el peso de estas componentes, podemos hacer el siguiente gráfico, donde se muestra un diagrama de barras donde a cada dimensión le asociamos el porcentaje de variación que explica:

```{r porcentajes variacion medianas}
fviz_eig(data_ACP_medianas, addlabels = TRUE, ylim = c(0,100))
```

A partir de la tabla y el gráfico podemos elegir dos o tres componentes principales, ya que a partir de la cuarta componente el porcentaje de variabilidad no aumenta lo suficiente como para considerar una dimensión más. Representemos estas variables en el espacio.

```{r circulo correlacion dim1-dim2 medianas}
fviz_pca_var(data_ACP_medianas, col.var = "contrib", repel = TRUE, axes = 1:2)
```

La mayoría de variables están bien representadas y contribuyen aproximadamente lo mismo al plano principal, exceptuando *enf_cardiovasculares* y *enf_sist_digestivo* debido al poco peso que tienen.

Podemos ver las contribuciones de cada variable al plano principal

```{r contribuciones plano principal medianas}
fviz_contrib(data_ACP_medianas, choice = "var", axes = 1:2,)
```

Veamos también la calidad de representación de las variables:

```{r grafico barras cos2 medianas}
fviz_cos2(data_ACP_medianas, choice = "var", axes = 1:2)
```

En estos dos gráficos podemos ver de forma clara la mala representación de estas variables.

Por último veamos una representación de los países en el plano principal con un biplot. Los colorearemos en función del IDH para ver si se agrupan en función de este. Podemos hacer cuatro grupos, separados por los cuartiles. Esto lo haremos también en los ACP de 1990 y 2019.

```{r grupos IDH medianas}
cuartiles_medianas <- new_data_medianas %>% 
  dplyr::select(idh) %>% 
  pull %>% 
  quantile(., probs = c(0.25, 0.5, 0.75))

# Clasificar los países en función de los cuartiles del IDH
new_data_medianas_clr <- new_data_medianas_clr %>%
  mutate(grupo_idh = case_when(idh <= cuartiles_medianas[1] ~ "Bajo", 
                               idh <= cuartiles_medianas[2] ~ "Medio Bajo", 
                               idh <= cuartiles_medianas[3] ~ "Medio Alto", 
                               TRUE ~ "Alto")) %>% 
  mutate(grupo_idh = factor(grupo_idh, levels = c("Bajo", "Medio Bajo", "Medio Alto", "Alto")))
```

```{r biplots dim1-dim2 medianas, fig.width=10, fig.height=10}
biplot_medianas <- fviz_pca_biplot(data_ACP_medianas, 
                col.var = "darkgrey",
                col.ind = new_data_medianas_clr$grupo_idh,
                palette = c("darkred", "lightcoral", "#4A90E2", "darkblue"),
                #col.ind = new_data_medianas_clr$idh,
                #gradient.cols = c("red", "cyan"),
                pointshape = 16,
                pointsize = 2,
                mean.point = FALSE,
                legend.title = "Grupo IDH",
                repel = TRUE,
                title = "Biplot medianas temporales"
                )

biplot_medianas
```

Podemos ver que los países con mayor IDH se agrupan en el tercer cuadrante, caracterizado por las enfermedades del sistema nervioso y las neoplasias, propias de países más desarrollados. Por otro lado, los países con menor IDH se agrupan en el primer cuadrante, caracterizado por las enfermedades infecciosas y parasitarias y los trastornos del embarazo, propias de países menos desarrollados. A su vez, podemos ver una transición del IDH entre el primer y el tercer cuadrante.

### ACP 1990

Veamos ahora un análisis en componentes principales donde tomaremos los datos de 1990. Construyamos primero este conjunto de datos.

```{r 1990}
new_data_1990 <- new_data %>%
  filter(año == 1990) %>%
  dplyr::select(codigo_Pais, enf_infec_paras:enf_cronicas, idh)
```

Veamos si hay alguna entrada que sea $0$.

```{r conteo ceros 1990}
new_data_1990 %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  summarise(total_ceros = sum(across(where(is.numeric), ~ sum(. == 0)))) %>% 
  glimpse
```

Como hay un $0$, para poder realizar la transformación *clr* lo tendremos que imputar. Lo vamos a sustituir por $0.65$ y luego aplicaremos la transformación *clr* y centraremos los datos.

```{r 1990 clr}
new_data_1990_clr <- new_data_1990 %>%
  mutate(across(enf_infec_paras:enf_cronicas, ~ replace(., . == 0, 0.65)))

new_data_1990_clr[, 2:12] <- new_data_1990_clr %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  clr %>%
  as_tibble

n = nrow(new_data_1990_clr)

# Matriz de centrado
Hn = diag(n) - 1/n

# Datos centrados
data_cen_1990 <- Hn %*% as.matrix(new_data_1990_clr[, 2:12]) %>% 
  as_tibble %>%
  mutate(codigo_Pais = new_data_1990_clr$codigo_Pais, .before = enf_infec_paras,) %>%
  mutate(idh = new_data_1990_clr$idh)
```

Antes de realizar el método de componentes principales, observemos la matriz de varianzas-covarianzas y la matriz de correlación.

```{r matriz covarianzas 1990}
S_1990 = cov(data_cen_1990[, 2:12])
cat("Matriz de varianzas-covarianzas\n")
S_1990
```

Podemos ver que los valores de las varianzas se agrupan entre $0.07792913$ y $0.71067096$, siendo el valor mínimo de *enf_cardiovasculares* y el máximo de *trastornos_mentales*. Debido a esta diferencia entre las varianzas, realizaremos el ACP escalado, ya que si no, las componentes principales le darían más peso a las variables con una alta varianza. Veamos de una forma más clara las varianzas ordenadas de menor a mayor.

```{r varianzas ordenadas 1990}
sort(diag(S_1990))
```

Por otro lado, la matriz de correlaciones es:

```{r matriz correlacion 1990, fig.height=6}
data_cen_1990 %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  cor(., method = "spearman") %>% 
  ggcorrplot(type = "upper", lab = TRUE, colors = c("red", "white", "blue"),
             title = "Matriz de correlaciones")
```

La mayor correlación positiva se encuentra entre *enf_sist_nervioso* y *neoplasias*, con un valor de $0.86$. Por otro lado, la mayor correlación negativa se encuentra entre *enf_sist_nervioso* y *trastornos_embarazo*, con un valor de $-0.75$.

Pasemos al estudio de las componentes principales. Calculemos los valores y vectores propios de la matriz de varianzas-covarianzas.

```{r ACP 1990}
data_ACP_1990 = prcomp(data_cen_1990[, 2:12], scale = TRUE)

rownames(data_ACP_1990$x) <- data_cen_1990$codigo_Pais
```

```{r veps 1990}
veps_1990 = data_ACP_1990$rotation

cat("Vectores propios\n")
veps_1990
```

Podemos ver que entre la primera y segunda componente le dan un peso considerable a todas las variables, menos a *enf_sist_digestivo*, la cual le da peso la tercera componente.

```{r vaps 1990}
vaps_1990 = get_eigenvalue(data_ACP_1990)

cat("Valores propios\n")
vaps_1990
```

A partir de esta tabla de valores podemos ver que con dos componentes principales nos permiten explicar aproximadamente el $58\%$ de la variación total. Para ver de una manera más detallada el peso de estas componentes, podemos hacer el siguiente gráfico, donde se muestra un diagrama de barras donde a cada dimensión le asociamos el porcentaje de variación que explica:

```{r porcentajes variacion 1990}
fviz_eig(data_ACP_1990, addlabels = TRUE, ylim = c(0,100))
```

A partir de la tabla y el gráfico podemos elegir dos componentes principales, ya que a partir de la tercera componente el porcentaje de variabilidad no aumenta lo suficiente como para considerar una dimensión más. Representemos estas variables en el espacio.

```{r circulo correlacion dim1-dim2 1990}
fviz_pca_var(data_ACP_1990, col.var = "contrib", repel = TRUE, axes = 1:2)
```

La mayoría de variables están bien representadas y contribuyen aproximadamente lo mismo al plano principal, exceptuando *enf_sist_digestivo* debido al poco peso que tiene.

Podemos ver las contribuciones de cada variable al plano principal

```{r contribuciones plano principal 1990}
fviz_contrib(data_ACP_1990, choice = "var", axes = 1:2,)
```

Veamos también la calidad de representación de las variables:

```{r grafico barras cos2 1990}
fviz_cos2(data_ACP_1990, choice = "var", axes = 1:2)
```

En estos dos gráficos podemos ver de forma clara la mala representación de *enf_sist_digestivo*.

Por último veamos una representación de los países en el plano principal con un biplot.

```{r grupos IDH 1990}
cuartiles_1990 <- new_data_1990 %>% 
  dplyr::select(idh) %>% 
  pull %>% 
  quantile(., probs = c(0.25, 0.5, 0.75))

# Clasificar los países en función de los cuartiles del IDH
new_data_1990_clr <- new_data_1990_clr %>%
  mutate(grupo_idh = case_when(idh <= cuartiles_1990[1] ~ "Bajo", 
                               idh <= cuartiles_1990[2] ~ "Medio Bajo", 
                               idh <= cuartiles_1990[3] ~ "Medio Alto", 
                               TRUE ~ "Alto")) %>% 
  mutate(grupo_idh = factor(grupo_idh, levels = c("Bajo", "Medio Bajo", "Medio Alto", "Alto")))
```

```{r biplots dim1-dim2 1990, fig.width=10, fig.height=10}
biplot_1990 <- fviz_pca_biplot(data_ACP_1990, 
                col.var = "darkgrey",
                col.ind = new_data_medianas_clr$grupo_idh,
                palette = c("darkred", "lightcoral", "#4A90E2", "darkblue"),
                #col.ind = new_data_medianas_clr$idh,
                #gradient.cols = c("red", "cyan"),
                pointshape = 16,
                pointsize = 2,
                mean.point = FALSE,
                legend.title = "Grupo IDH",
                repel = TRUE,
                title = "Biplot 1990"
                )

biplot_1990
```

En este gráfico no podemos ver una agrupación clara.

### ACP 2019

Veamos ahora un análisis en componentes principales donde tomaremos los datos de 2019. Construyamos primero este conjunto de datos.

```{r 2019}
new_data_2019 <- new_data %>%
  filter(año == 2019) %>%
  dplyr::select(codigo_Pais, enf_infec_paras:enf_cronicas, idh)
```

Veamos si hay alguna entrada que sea $0$.

```{r conteo ceros 2019}
new_data_2019 %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  summarise(total_ceros = sum(across(where(is.numeric), ~ sum(. == 0)))) %>% 
  glimpse
```

Como hay un $0$, para poder realizar la transformación *clr* lo tendremos que imputar. Lo vamos a sustituir por $0.65$ y luego aplicaremos la transformación *clr* y centraremos los datos.

```{r 2019 clr}
new_data_2019_clr <- new_data_2019 %>%
  mutate(across(enf_infec_paras:enf_cronicas, ~ replace(., . == 0, 0.65)))

new_data_2019_clr[, 2:12] <- new_data_2019_clr %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  clr %>%
  as_tibble

n = nrow(new_data_2019_clr)

# Matriz de centrado
Hn = diag(n) - 1/n

# Datos centrados
data_cen_2019 <- Hn %*% as.matrix(new_data_2019_clr[, 2:12]) %>% 
  as_tibble %>%
  mutate(codigo_Pais = new_data_2019_clr$codigo_Pais, .before = enf_infec_paras,) %>%
  mutate(idh = new_data_2019_clr$idh)
```

Antes de realizar el método de componentes principales, observemos la matriz de varianzas-covarianzas y la matriz de correlación.

```{r matriz covarianzas 2019}
S_2019 = cov(data_cen_2019[, 2:12])
cat("Matriz de varianzas-covarianzas\n")
S_2019
```

Podemos ver que los valores de las varianzas se agrupan entre $0.06812191$ y $0.73138636$, siendo el valor mínimo de *enf_sist_digestivo* y el máximo de *trastornos_mentales*. Debido a esta diferencia entre las varianzas, realizaremos el ACP escalado, ya que si no, las componentes principales le darían más peso a las variables con una alta varianza. Veamos de una forma más clara las varianzas ordenadas de menor a mayor.

```{r varianzas ordenadas 2019}
sort(diag(S_2019))
```

Por otro lado, la matriz de correlaciones es:

```{r matriz correlacion 2019, fig.height=6}
data_cen_2019 %>%
  dplyr::select(enf_infec_paras:enf_cronicas) %>%
  cor(., method = "spearman") %>% 
  ggcorrplot(type = "upper", lab = TRUE, colors = c("red", "white", "blue"),
             title = "Matriz de correlaciones")
```

La mayor correlación positiva se encuentra entre *enf_sist_nervioso* y *neoplasias*, con un valor de $0.67$. Por otro lado, la mayor correlación negativa se encuentra entre *causas_externas* y *enf_cronicas*, con un valor de $-0.69$.

Pasemos al estudio de las componentes principales. Calculemos los valores y vectores propios de la matriz de varianzas-covarianzas.

```{r ACP 2019}
data_ACP_2019 = prcomp(data_cen_2019[, 2:12], scale = TRUE)

rownames(data_ACP_2019$x) <- data_cen_2019$codigo_Pais
```

```{r veps 2019}
veps_2019 = data_ACP_2019$rotation

cat("Vectores propios\n")
veps_2019
```

Podemos ver que entre la primera y segunda componente le dan un peso considerable a la mayoría de las variables, exceptuando quizás a *enf_infec_paras*, *enf_cardiovasculares*, *infecciones_respi* y *enf_sist_digestivo*, aunque la tercera y cuarta componentes ya les dan más peso.

```{r vaps 2019}
vaps_2019 = get_eigenvalue(data_ACP_2019)

cat("Valores propios\n")
vaps_2019
```

A partir de esta tabla de valores podemos ver que con dos componentes principales nos permiten explicar aproximadamente el $60\%$ de la variación total. Para ver de una manera más detallada el peso de estas componentes, podemos hacer el siguiente gráfico, donde se muestra un diagrama de barras donde a cada dimensión le asociamos el porcentaje de variación que explica:

```{r porcentajes variacion 2019}
fviz_eig(data_ACP_2019, addlabels = TRUE, ylim = c(0,100))
```

A partir de la tabla y el gráfico podemos elegir dos o tres componentes principales, ya que a partir de la cuarta componente el porcentaje de variabilidad no aumenta lo suficiente como para considerar una dimensión más. Representemos estas variables en el espacio.

```{r circulo correlacion dim1-dim2 2019}
fviz_pca_var(data_ACP_2019, col.var = "contrib", repel = TRUE, axes = 1:2)
```

La mayoría de variables están bien representadas y contribuyen aproximadamente lo mismo al plano principal, exceptuando *enf_sist_digestivo* y *enf_cardiovasculares* debido al poco peso que tienen.

Podemos ver las contribuciones de cada variable al plano principal

```{r contribuciones plano principal 2019}
fviz_contrib(data_ACP_2019, choice = "var", axes = 1:2,)
```

Veamos también la calidad de representación de las variables:

```{r grafico barras cos2 2019}
fviz_cos2(data_ACP_2019, choice = "var", axes = 1:2)
```

En estos dos gráficos podemos ver de forma clara la mala representación de *enf_sist_digestivo* y *enf_cardiovasculares*, seguidas de *infecciones_respi* y *enf_infec_paras*.

Por último veamos una representación de los países en el plano principal con un biplot.

```{r grupos IDH 2019}
cuartiles_2019 <- new_data_2019 %>% 
  dplyr::select(idh) %>% 
  pull %>% 
  quantile(., probs = c(0.25, 0.5, 0.75))

# Clasificar los países en función de los cuartiles del IDH
new_data_2019_clr <- new_data_2019_clr %>%
  mutate(grupo_idh = case_when(idh <= cuartiles_2019[1] ~ "Bajo", 
                               idh <= cuartiles_2019[2] ~ "Medio Bajo", 
                               idh <= cuartiles_2019[3] ~ "Medio Alto", 
                               TRUE ~ "Alto")) %>% 
  mutate(grupo_idh = factor(grupo_idh, levels = c("Bajo", "Medio Bajo", "Medio Alto", "Alto")))
```

```{r biplots dim1-dim2 2019, fig.width=10, fig.height=10}
biplot_2019 <- fviz_pca_biplot(data_ACP_2019, 
                col.var = "darkgrey",
                col.ind = new_data_medianas_clr$grupo_idh,
                palette = c("darkred", "lightcoral", "#4A90E2", "darkblue"),
                #col.ind = new_data_medianas_clr$idh,
                #gradient.cols = c("red", "cyan"),
                pointshape = 16,
                pointsize = 2,
                mean.point = FALSE,
                legend.title = "Grupo IDH",
                repel = TRUE,
                title = "Biplot 2019"
                )

biplot_2019
```

En este gráfico tampoco podemos ver una agrupación clara.

Para acabar veamos juntos los tres gráficos que hemos analizado:

```{r resumen biplots dim1-dim2, fig.width=20, fig.height=20}
grid.arrange(biplot_1990, biplot_2019, biplot_medianas, ncol = 2)
```

## 7 - Análisis en coordenadas principales

Vamos a realizar también un análisis en coordenadas principales (o escalamiento multidimensional). Este análisis se hará, de nuevo, en los tres conjuntos de datos que hemos construido en el ACP. Por su naturaleza composicional, no podemos utilizar las distancias Euclídea o de Manhattan. En su lugar, utilizaremos la distancia de Aitchison, que es la distancia Euclídea entre dos muestras después de aplicar la transformación CLR. Cuando representemos los puntos, de nuevo los colorearemos según su nivel de IDH.

### MDS medianas

Mostremos las distancias entre los primeros 8 países de la tabla.

```{r matriz distancias medianas}
dist_medianas <- dist(new_data_medianas_clr[, 2:12])
dist_matrix_medianas <- as.matrix(dist_medianas)
colnames(dist_matrix_medianas) <- new_data_medianas_clr$codigo_Pais
rownames(dist_matrix_medianas) <- new_data_medianas_clr$codigo_Pais

dist_matrix_medianas[1:8, 1:8]
```

Ahora, aplicamos el método de coordenadas principales con la función de R `cmdscale`, usando la matriz de distancias anterior y especificando $k = 2$ (dos componentes principales).

```{r mds medianas, warning=FALSE}
data_MDS_medianas <- cmdscale(dist_medianas, k = 2) %>% 
  as_tibble() %>% 
  mutate(grupo_idh = new_data_medianas_clr$grupo_idh)

rownames(data_MDS_medianas) <- new_data_medianas_clr$codigo_Pais
colnames(data_MDS_medianas) <- c("Dim.1", "Dim.2", "grupo_idh")

data_MDS_medianas %>% 
  slice_head(n = 10)
```

Mostramos el gráfico de la matriz de distancias.

```{r grafico mds medianas}
ggscatter(data_MDS_medianas, 
          x = "Dim.1",
          y = "Dim.2",
          size = 1,
          color = "grupo_idh",
          label = rownames(data_MDS_medianas),
          repel = TRUE,
          palette = c("darkred", "lightcoral", "#4A90E2", "darkblue"),
          title = "MDS medianas")
```

Podemos apreciar que el idh es inversamente proporcional a la segunda dimensión, ya que, de forma general, cuanto más IDH tiene un país, más abajo está.

Por último, calculemos los coeficientes de precisión a partir de los valores propios de la matriz de productos cruzados.

```{r precision medianas}
Q_medianas = as.matrix(new_data_medianas_clr[, 2:12]) %*% t(as.matrix(new_data_medianas_clr[, 2:12]))

vaps_medianas = eigen(Q_medianas)$values

m_12_medianas = (sum(abs(vaps_medianas[1:2])) / sum(abs(vaps_medianas))) * 100

m_22_medianas = (sum(vaps_medianas[1:2]^2)/ sum(vaps_medianas^2)) * 100

m_12_medianas
m_22_medianas
```

-   $m_{1,2} =$ `r m_12_medianas`
-   $m_{2,2} =$ `r m_22_medianas`

con lo que vemos que hay una buena representación.

### MDS 1990

Mostremos las distancias entre los primeros 8 países de la tabla.

```{r matriz distancias 1990}
dist_1990 <- dist(new_data_1990_clr[, 2:12])
dist_matrix_1990 <- as.matrix(dist_1990)
colnames(dist_matrix_1990) <- new_data_1990_clr$codigo_Pais
rownames(dist_matrix_1990) <- new_data_1990_clr$codigo_Pais

dist_matrix_1990[1:8, 1:8]
```

Ahora, aplicamos el método de coordenadas principales con la función de R `cmdscale`, usando la matriz de distancias anterior y especificando $k = 2$ (dos componentes principales).

```{r mds 1990, warning=FALSE}
data_MDS_1990 <- cmdscale(dist_1990, k = 2) %>% 
  as_tibble() %>% 
  mutate(grupo_idh = new_data_1990_clr$grupo_idh)

rownames(data_MDS_1990) <- new_data_1990_clr$codigo_Pais
colnames(data_MDS_1990) <- c("Dim.1", "Dim.2", "grupo_idh")

data_MDS_1990 %>% 
  slice_head(n = 10)
```

Mostramos el gráfico de la matriz de distancias.

```{r grafico mds 1990}
ggscatter(data_MDS_1990, 
          x = "Dim.1",
          y = "Dim.2",
          size = 1,
          color = "grupo_idh",
          label = rownames(data_MDS_1990),
          repel = TRUE,
          palette = c("darkred", "lightcoral", "#4A90E2", "darkblue"),
          title = "MDS 1990")
```

Podemos ver en la parte superior una agrupación de los países con un IDH bajo, mientras que en la parte inferior izquierda se agrupan los países con un IDH alto.

Por último, calculemos los coeficientes de precisión a partir de los valores propios de la matriz de productos cruzados.

```{r precision 1990}
Q_1990 = as.matrix(new_data_1990_clr[, 2:12]) %*% t(as.matrix(new_data_1990_clr[, 2:12]))

vaps_1990 = eigen(Q_1990)$values

m_12_1990 = (sum(abs(vaps_1990[1:2])) / sum(abs(vaps_1990))) * 100

m_22_1990 = (sum(vaps_1990[1:2]^2)/ sum(vaps_1990^2)) * 100

m_12_1990
m_22_1990
```

-   $m_{1,2} =$ `r m_12_1990`
-   $m_{2,2} =$ `r m_22_1990`

Con estos valores de los coeficientes de precisión vemos que hay una buena representación.

### MDS 2019

Mostremos las distancias entre los primeros 8 países de la tabla.

```{r matriz distancias 2019}
dist_2019 <- dist(new_data_2019_clr[, 2:12])
dist_matrix_2019 <- as.matrix(dist_2019)
colnames(dist_matrix_2019) <- new_data_2019_clr$codigo_Pais
rownames(dist_matrix_2019) <- new_data_2019_clr$codigo_Pais

dist_matrix_2019[1:8, 1:8]
```

Ahora, aplicamos el método de coordenadas principales con la función de R `cmdscale`, usando la matriz de distancias anterior y especificando $k = 2$ (dos componentes principales).

```{r mds 2019, warning=FALSE}
data_MDS_2019 <- cmdscale(dist_2019, k = 2) %>% 
  as_tibble() %>% 
  mutate(grupo_idh = new_data_2019_clr$grupo_idh)

rownames(data_MDS_2019) <- new_data_2019_clr$codigo_Pais
colnames(data_MDS_2019) <- c("Dim.1", "Dim.2", "grupo_idh")

data_MDS_2019 %>% 
  slice_head(n = 10)
```

Mostramos el gráfico de la matriz de distancias.

```{r grafico mds 2019}
ggscatter(data_MDS_2019, 
          x = "Dim.1",
          y = "Dim.2",
          size = 1,
          color = "grupo_idh",
          label = rownames(data_MDS_2019),
          repel = TRUE,
          palette = c("darkred", "lightcoral", "#4A90E2", "darkblue"),
          title = "MDS 2019")
```

En este gráfico también se puede apreciar una transición de abajo hacia arriba de países con más IDH hacia países con menos IDH.

Por último, calculemos los coeficientes de precisión a partir de los valores propios de la matriz de productos cruzados.

```{r precision 2019}
Q_2019 = as.matrix(new_data_2019_clr[, 2:12]) %*% t(as.matrix(new_data_2019_clr[, 2:12]))

vaps_2019 = eigen(Q_2019)$values

m_12_2019 = (sum(abs(vaps_2019[1:2])) / sum(abs(vaps_2019))) * 100

m_22_2019 = (sum(vaps_2019[1:2]^2)/ sum(vaps_2019^2)) * 100

m_12_2019
m_22_2019
```

-   $m_{1,2} =$ `r m_12_2019`
-   $m_{2,2} =$ `r m_22_2019`

Con estos valores de los coeficientes de precisión vemos que hay una buena representación.

## 8 - Ajuste de modelo NBMM

Con el objetivo de ver cómo afecta el IDH al número de muertes por diferentes causas, vamos a ajustar un modelo binomial negativo mixto. Antes de entrar en detalles, conviene justificar por qué utilizamos un modelo Binomial Negativo en lugar de uno Poisson, que suele ser el más usual para modelizar datos de conteo.

### Motivación para usar el modelo Binomial Negativo

Los modelos de regresión Poisson asumen que la media y la varianza de la variable respuesta son iguales (esto es, $E[Y] = \text{Var}(Y)$), lo que se conoce como *equidispersión*. Sin embargo, en el caso de conteo de muertes podemos observar *sobredispersión*, es decir, que la varianza exceda notablemente a la media. En esos casos, el modelo Poisson tiende a infravalorar la probabilidad de observar valores atípicamente altos, dando lugar a errores sistemáticos en la estimación de los parámetros y de las incertidumbres asociadas.

Para ilustrar este fenómeno, elegimos un país concreto (por ejemplo, España) y examinamos el número de muertes anuales causadas por enfermedades del sistema nervioso entre 1990 y 2019. Si agregamos estos datos y calculamos la media y varianza observadas, obtenemos

```{r media y varianza España}
new_data %>%
  filter(pais == "España") %>%
  summarise(mean = mean(enf_sist_nervioso), var = var(enf_sist_nervioso))
```

Mientras que el modelo Poisson sólo encaja bien si $\hat{\mu} \approx \hat{\sigma}^2$, vemos que $\hat{\sigma}^2 = 44076945$ es muy superior a $26381.7$, indicando sobredispersión. Esto haría que el modelo Poisson:

-   Subestime sistemáticamente la probabilidad de observar años con conteos muy altos.
-   Proporcione intervalos de confianza demasiado estrechos para los parámetros.

La regresión Binomial Negativa soluciona ese inconveniente al permitir que la varianza sea mayor que la media mediante un parámetro adicional de sobredispersión $\alpha$, cumpliendo:

$$
\text{Var}(Y) = E[Y] + \alpha\ \bigl(E[Y]\bigr)^2.
$$

De este modo, si los conteos presentan una variabilidad superior a la que asumiría un modelo Poisson, la Binomial Negativa constituye una elección más adecuada y reduce el sesgo en las estimaciones.

### Descripción del NBMM

Ajustaremos un modelo a los datos sobre muertes causadas por enfermedades del sistema nervioso. Para analizar el resto de causas se procede de manera análoga. Basándonos en la motivación anterior, proponemos un modelo Binomial Negativo Mixto
(NBMM) que, además de corregir la sobredispersión, incorpora un \textit{offset} para tener
en cuenta el total anual de muertes en cada país y un efecto aleatorio que capture
la heterogeneidad intrínseca entre países, además de un polinomio cúbico para capturar el efecto del tiempo. La formulación es la siguiente:

$$
\log(\mu_{ij}) = \log\bigl(N_{ij}\bigr) + \beta_{0} + \beta_{1}x_{ij} + \beta_{2}t_j + \beta_{3}t_j^2 + \beta_{4}t_j^3 + u_i,
$$

donde 

-   $\mu_{ij}$ es la media de muertes causadas por enfermedades del sistema nervioso en el país $i$ en el año $j$.
-   $N_{ij}$ es el total de muertes en el país $i$ en el año $j$.
-   $x_{ij}$ es el IDH del país $i$ en el año $j$.
-   $t_j$ es el año.
-   $\beta_{0}$, $\beta_{1}$, $\beta_{2}$, $\beta_{3}$, $\beta_{4}$ son los coeficientes a estimar.
-   $u_i \sim \mathcal{N}(0,\sigma^2)$ es el efecto aleatorio país.

### Estimación del modelo

Para estimar el modelo, primero vamos a reescalar nuestra variable año de forma que caiga en el intervalo $[0,1]$ para evitar posibles errores por *overflow*. Además, al querer un polinomio cúbico necesitamos las variables año al cuadrado y año al cubo.

```{r polinomio año}
new_data <- new_data %>% 
  mutate(año = as.numeric(año)) %>% 
  mutate(año = (año - min(año)) / (max(año) - min(año))) %>% 
  rowwise() %>%  
  mutate(año2 = año^2, .after = año) %>% 
  mutate(año3 = año^3, .after = año2) %>% 
  ungroup()
```

` #Realizaremos tres ajustes: uno con enfermedades del sistema nervioso, con una alta correlación positiva con el IDH; otro con enfermedades del sistema digestivo, con una correlación casi nula con el IDH; y otro con trastornos del embarazo, con una alta correlación negativa con el IDH. `

Ahora procedamos a realizar el ajuste de nuestro modelo.

```{r modelo 1 NBMM enf_sist_nervioso, echo=TRUE, warning = FALSE, message = FALSE}
N = new_data$total_muertes # offset

m_enf_sist_nervioso1 = glmm.nb(enf_sist_nervioso ~ idh + año + año2 + año3 + offset(log(N)),
                              random = ~ 1 | pais, data = new_data)
```

```{r summary modelo 1}
summary(m_enf_sist_nervioso1)
```

Podemos ver que el p-valor de la variable *año* es alto ($0.2621$) lo que sugiere que la variable no es significativa, es decir, que puede que su coeficiente asociado valga $0$. Vamos a eliminarla y comparar el modelo resultante.

```{r modelo 0 NBMM enf_sist_nervioso, echo=TRUE, warning = FALSE, message = FALSE}
m_enf_sist_nervioso0 = glmm.nb(enf_sist_nervioso ~ idh + año2 + año3 + offset(log(N)),
                              random = ~ 1 | pais, data = new_data)
```

```{r summary modelo 0}
summary(m_enf_sist_nervioso0)
```

En este nuevo modelo vemos que todas las variables tienen un p-valor bajo, lo que sugiere que son significativas. Vamos a comparar ambos modelos calculando la diferencia de las desviaciones $\Delta D$ y viendo si se encuentra en la región crítica de la distribución $\chi^2(1)$

Sea $M_0$ el modelo más simple con hipótesis
$$
    H_0:\; (\mathbf{\beta}, \alpha) = (\beta_{0,2}, \beta_{1,2}, \beta_{3,2}, \beta_{4,2}, \alpha)^T,
$$
y sea $M_1$ el modelo que incluye el parámetro para la variable \textit{año}, con hipótesis
$$
    H_1:\; (\mathbf{\beta}, \alpha) = (\beta_{0,2}, \beta_{1,2}, \beta_{2,2}, \beta_{3,2}, \beta_{4,2}, \alpha)^T.
$$

La desviación del modelo $M_0$ es:

```{r D0}
Y = new_data$enf_sist_nervioso
lnN = log(new_data$total_muertes)

b0 = m_enf_sist_nervioso0$coefficients$fixed
a0 = m_enf_sist_nervioso0$sigma
u0 = rep(m_enf_sist_nervioso0$coefficients$random$pais, each = 30)
X0 <- m_enf_sist_nervioso0$data %>% dplyr::select(idh, año2, año3) %>% cbind(1, .) %>%
      as.matrix()
colnames(X0)[1] = "intercept"
eta0 = lnN + X0 %*% b0 + u0

D0 = 2*(Y%*%(log(Y)-eta0)-(1/a0 + Y)%*%log((1+a0*Y)/(1+a0*exp(eta0))))
D0
```

y el p-valor $P(\chi^2_{1331} \ge D_0)$ es

```{r p-valor 0}
pchisq(D0, df = 1331, lower.tail = FALSE)
```

lo que sugiere que el modelo $M_0$ es adecuado. Veamos ahora el modelo $M_1$.

```{r D1}
Y = new_data$enf_sist_nervioso
lnN = log(new_data$total_muertes)

b1 = m_enf_sist_nervioso1$coefficients$fixed
a1 = m_enf_sist_nervioso1$sigma
u1 = rep(m_enf_sist_nervioso1$coefficients$random$pais, each = 30)
X1 <- m_enf_sist_nervioso1$data %>% dplyr::select(idh, año, año2, año3) %>% cbind(1, .) %>%
      as.matrix()
colnames(X1)[1] = "intercept"
eta1 = lnN + X1 %*% b1 + u1

D1 = 2*(Y%*%(log(Y)-eta1)-(1/a1 + Y)%*%log((1+a1*Y)/(1+a1*exp(eta1))))
D1
```

y el p-valor $P(\chi^2_{1330} \ge D_1)$ es

```{r p-valor 1}
pchisq(D1, df = 1330, lower.tail = FALSE)
```

lo que sugiere que el modelo $M_1$ es adecuado. Por último, comparemos ambos modelos con el estadístico $\Delta D = D_0 - D_1$, que sigue la distribución $\Delta D \sim \chi^2(1)$

```{r estadistico}
DeltaD = D0 - D1
DeltaD
```

y el p-valor $P(\chi^2_{1} \ge \Delta D)$ es

```{r p-valor estadistico}
pchisq(DeltaD, df = 1, lower.tail = FALSE)
```

Como el estadístico no se encuentra en la región crítica, elegiremos el modelo $M_0$ por ser más simple.

### Análisis de los residuales

Vamos a analizar los residuales del modelo ajustado. Primero, extraemos los residuales del modelo y los organizamos en un dataframe junto con el año, el país y el grupo de IDH.

```{r residuales}
residuales = m_enf_sist_nervioso0$residuals

analisis_residuales = data.frame(residuales = residuales[,2], año = new_data$año, pais = new_data$pais,
                                 grupo_idh = new_data$idh)

cuartiles <- new_data %>% 
  dplyr::select(idh) %>% 
  pull %>% 
  quantile(., probs = c(0.25, 0.5, 0.75))

# Clasificar los países en función de los cuartiles del IDH
analisis_residuales <- analisis_residuales %>%
  mutate(grupo_idh = case_when(grupo_idh <= cuartiles_medianas[1] ~ "Bajo", 
                               grupo_idh <= cuartiles_medianas[2] ~ "Medio Bajo", 
                               grupo_idh <= cuartiles_medianas[3] ~ "Medio Alto", 
                               TRUE ~ "Alto")) %>% 
  mutate(grupo_idh = factor(grupo_idh, levels = c("Bajo", "Medio Bajo", "Medio Alto", "Alto"))) %>% 
  mutate(año = año*29 + 1990) # Reescalamos el año para que sea el original
```

Veamos cómo se distribuyen según el año:

``` {r boxplot resiudales año}
analisis_residuales %>% 
  dplyr::select(c(residuales, año)) %>%
  mutate(año = factor(año)) %>% 
  ggplot(aes(x = año, y = residuales)) +
  geom_boxplot(width = 0.75, color = "black") +
  theme_minimal() +
  labs(x = "Año", y = "Residuales") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

Ahora según el nivel de IDH:

``` {r boxplot resiudales idh}
analisis_residuales %>% 
  dplyr::select(c(residuales, grupo_idh)) %>%
  ggplot(aes(x = grupo_idh, y = residuales)) +
  geom_boxplot(width = 0.3, color = c("darkred", "lightcoral", "#4A90E2", "darkblue")) +
  theme_minimal() +
  labs(x = "Nivel de IDH", y = "Residuales") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
```

Y, por último, según el país:

``` {r boxplot resiudales pais}
analisis_residuales %>% 
  dplyr::select(c(residuales, pais)) %>%
  ggplot(aes(x = pais, y = residuales)) +
  geom_boxplot(width = 0.8, color = "black") +
  theme_minimal() +
  labs(x = "País", y = "Residuales") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r include=FALSE}

car::qqPlot(residuales[,1])

shapiro.test(residuales[,1])
```

```{r include=FALSE}
u = m_enf_sist_nervioso1$coefficients$random$pais
u
sd(u)
mean(u)
```

```{r include=FALSE}
plot(density(u))
shapiro.test(u)
```

